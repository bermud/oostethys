package org.oostethys.harvester;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

public class DataBase {

	Connection conn;

	public void delteTable() {

		// Statement s = conn.createStatement();
		// s.executeUpdate("DROP TABLE, autoGeneratedKeys)

	}

	public void shutdown() throws SQLException {

		Statement st = conn.createStatement();

		// db writes out to files and performs clean shuts down
		// otherwise there will be an unclean shutdown
		// when program ends
		st.execute("SHUTDOWN");
		conn.close(); // if there are no other open connection
	}

	public synchronized void update(String expression) throws SQLException {

		Statement st = null;

		st = conn.createStatement(); // statements

		int i = st.executeUpdate(expression); // run the query

		if (i == -1) {
			System.out.println("db error : " + expression);
		}

		st.close();
	} // void update()

	public synchronized ResultSet query(String expression) throws SQLException {
		Statement st = null;
		st = conn.createStatement(); // statements
		ResultSet set = st.executeQuery(expression); // run the query
		dump(set);
		return set;
	} // void update()

	public static void dump(ResultSet rs) throws SQLException {

		// the order of the rows in a cursor
		// are implementation dependent unless you use the SQL ORDER statement
		ResultSetMetaData meta = rs.getMetaData();
		int colmax = meta.getColumnCount();
		int i;
		Object o = null;

		// the result set is a cursor into the data. You can only
		// point to one row at a time
		// assume we are pointing to BEFORE the first row
		// rs.next() points to next row and returns true
		// or false if there is no next row, which breaks the loop
		for (; rs.next();) {
			for (i = 0; i < colmax; ++i) {
				o = rs.getObject(i + 1); // Is SQL the first column is
				// indexed

				// with 1 not 0
				System.out.print(o.toString() + " ");
			}

			System.out.println(" ");
		}
	}

	public void insert(String s) {

		try {
			update(s);
		} catch (SQLException ex) {

		}

	}

	public void test() {

		try {

			update("DROP TABLE tobs IF EXISTS");
			update("DROP TABLE tlat");
			update("DROP TABLE tlon");
			update("DROP TABLE tz");

			// make an empty table
			//
			// by declaring the id column IDENTITY, the db will
			// automatically
			// generate unique values for new rows- useful for row keys
			update("CREATE TABLE tlat (id IDENTITY, lat DOUBLE)");
			update("CREATE UNIQUE INDEX ilat ON tlat(lat)");

			update("CREATE TABLE tlon (id IDENTITY, lon DOUBLE)");
			update("CREATE UNIQUE INDEX ilon ON tlon(lon)");

			update("CREATE TABLE tz (id IDENTITY, z DOUBLE)");
			update("CREATE UNIQUE INDEX iz ON tz(z)");

			update("CREATE TABLE tobs (id IDENTITY, lat INT, lon INT, z INT)");

			update("ALTER TABLE tobs ADD FOREIGN KEY (lat) REFERENCES tlat(id)");
			update("ALTER TABLE tobs ADD FOREIGN KEY (lon) REFERENCES tlon(id)");
			update("ALTER TABLE tobs ADD FOREIGN KEY (z) REFERENCES tz(id)");

		} catch (SQLException ex2) {

			// ignore
			ex2.printStackTrace(); // second time we run program
			// should throw execption since table
			// already there
			//
			// this will have no effect on the db
		}

		try {

			// add some rows - will create duplicates if run more then once
			// the id column is automatically generated

			insert("INSERT INTO tlat VALUES (39.15)");

			insert("INSERT INTO tlat (lat) VALUES (39.14)");
			insert("INSERT INTO tlat (lat) VALUES ( 39.10)");
			insert("INSERT INTO tlat (lat) VALUES (39.12)");
			insert("INSERT INTO tlat (lat) VALUES (39.14)");

			getClosestPoint(39.13, -70.15);

			// at end of program
			shutdown();
		} catch (SQLException ex3) {
			ex3.printStackTrace();
		}
	} // main()

	public void getClosestPoint(double lat, double lon) {
		try {
			Statement st = null;
			ResultSet set = null;
			String exp = null;
			st = conn.createStatement(); // statements

			
			System.out.println("get lower lat ");
			exp = ("SELECT * FROM tlat WHERE lat <= " + lat + " ORDER BY lat DESC LIMIT 1");
			set = st.executeQuery(exp);
			set.next();
			

			int ilatmin = set.getInt(1);
			double vlatmin = set.getDouble(2);
			System.out.println("ilatmin " + ilatmin + "  " + "vlatmin "
					+ vlatmin);
			set.close();

			System.out.println("get upper lat ");

			exp = ("SELECT * FROM tlat WHERE lat >= " + lat + " LIMIT 1");
			set = st.executeQuery(exp);
			set.next();
			int ilatmax = set.getInt(1);
			double vlatmax = set.getDouble(2);
			System.out.println("ilatmax " + ilatmax + "  " + "vlatmax "
					+ vlatmax);
			
			////
			
			System.out.println("get lower lon ");
			exp = ("SELECT * FROM tlon WHERE lon <= " + lon + " ORDER BY lon DESC LIMIT 1");
			set = st.executeQuery(exp);
			set.next();
			

			int ilonmin = set.getInt(1);
			double vlonmin = set.getDouble(2);
			System.out.println("ilonmin " + ilonmin + "  " + "vlonmin "
					+ vlonmin);
			set.close();

			System.out.println("get upper lat ");

			exp = ("SELECT * FROM tlon WHERE lon >= " + lon + " LIMIT 1");
			set = st.executeQuery(exp);
			set.next();
			int ilonmax = set.getInt(1);
			double vlonmax = set.getDouble(2);
			System.out.println("ilonmax " + ilonmax + "  " + "vlonmax "
					+ vlonmax);
			
			
			
			

		} catch (SQLException ex3) {
			ex3.printStackTrace();
		}

	}

	public void createDB() {

		try {
			Class.forName("org.hsqldb.jdbcDriver");
		} catch (Exception e) {
			System.out.println("ERROR: failed to load HSQLDB JDBC driver.");
			e.printStackTrace();
			return;
		}

		try {
			conn = DriverManager.getConnection("jdbc:hsqldb:scoop");

		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public void harvest() {

	}

	public static void main(String[] args) {
		DataBase h = new DataBase();
		h.createDB();

		h.test();

	}

}
